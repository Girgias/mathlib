/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import analysis.convex.topology
/-!
# Locally convex topological modules
A `locally_convex_space` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.
In a module, this is equivalent to `0` satisfying such properties.
## Main results
- `locally_convex_space_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `seminorm.locally_convex_space` : a topology generated by a family of seminorms is locally convex
- `normed_space.locally_convex_space` : a normed space is locally convex
## TODO
- define a structure `locally_convex_filter_basis`, extending `module_filter_basis`, for filter
  bases generating a locally convex topology
- show that any locally convex topology is generated by a family of seminorms
-/

open topological_space filter

open_locale topological_space

section semimodule

/-- A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class locally_convex_space (𝕜 E : Type*) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E]
  [topological_space E] : Prop :=
(convex_basis : ∀ x : E, (𝓝 x).has_basis (λ (s : set E), s ∈ 𝓝 x ∧ convex 𝕜 s) id)

variables (𝕜 E : Type*) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E]

lemma locally_convex_space_iff :
  locally_convex_space 𝕜 E ↔
  ∀ x : E, (𝓝 x).has_basis (λ (s : set E), s ∈ 𝓝 x ∧ convex 𝕜 s) id :=
⟨@locally_convex_space.convex_basis _ _ _ _ _ _, locally_convex_space.mk⟩

lemma locally_convex_space.of_bases {ι : Type*} (b : E → ι → set E) (p : ι → Prop)
  (hbasis : ∀ x : E, (𝓝 x).has_basis p (b x)) (hconvex : ∀ x i, p i → convex 𝕜 (b x i)) :
  locally_convex_space 𝕜 E :=
⟨λ x, (hbasis x).to_has_basis
  (λ i hi, ⟨b x i, ⟨⟨(hbasis x).mem_of_mem hi, hconvex x i hi⟩, le_refl (b x i)⟩⟩)
  (λ s hs, ⟨(hbasis x).index s hs.1,
    ⟨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1⟩⟩)⟩

lemma locally_convex_space.convex_basis_zero [locally_convex_space 𝕜 E] :
  (𝓝 0 : filter E).has_basis (λ s, s ∈ (𝓝 0 : filter E) ∧ convex 𝕜 s) id :=
locally_convex_space.convex_basis 0

lemma locally_convex_space_iff_exists_convex_subset :
  locally_convex_space 𝕜 E ↔ ∀ x : E, ∀ U ∈ 𝓝 x, ∃ S ∈ 𝓝 x, convex 𝕜 S ∧ S ⊆ U :=
(locally_convex_space_iff 𝕜 E).trans (forall_congr $ λ x, has_basis_self)

end semimodule

section module

variables (𝕜 E : Type*) [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E]
  [topological_add_group E]

lemma locally_convex_space.of_basis_zero {ι : Type*} (b : ι → set E) (p : ι → Prop)
  (hbasis : (𝓝 0).has_basis p b) (hconvex : ∀ i, p i → convex 𝕜 (b i)) :
  locally_convex_space 𝕜 E :=
begin
  refine locally_convex_space.of_bases 𝕜 E (λ (x : E) (i : ι), ((+) x) '' b i) p (λ x, _)
    (λ x i hi, (hconvex i hi).translate x),
  rw ← map_add_left_nhds_zero,
  exact hbasis.map _
end

lemma locally_convex_space_iff_zero :
  locally_convex_space 𝕜 E ↔
  (𝓝 0 : filter E).has_basis (λ (s : set E), s ∈ (𝓝 0 : filter E) ∧ convex 𝕜 s) id :=
⟨λ h, @locally_convex_space.convex_basis _ _ _ _ _ _ h 0,
 λ h, locally_convex_space.of_basis_zero 𝕜 E _ _ h (λ s, and.right)⟩

lemma locally_convex_space_iff_exists_convex_subset_zero :
  locally_convex_space 𝕜 E ↔
  ∀ U ∈ (𝓝 0 : filter E), ∃ S ∈ (𝓝 0 : filter E), convex 𝕜 S ∧ S ⊆ U :=
(locally_convex_space_iff_zero 𝕜 E).trans has_basis_self

end module

section lattice_ops

variables {ι : Sort*} {𝕜 E F : Type*} [ordered_semiring 𝕜] [add_comm_monoid E]
  [module 𝕜 E] [add_comm_monoid F] [module 𝕜 F] {ts : set (topological_space E)}
  (h : ∀ t ∈ ts, @locally_convex_space 𝕜 E  _ _ _ t) {ts' : ι → topological_space E}
  (h' : ∀ i, @locally_convex_space 𝕜 E  _ _ _ (ts' i)) {t₁ t₂ : topological_space E}
  (h₁ : @locally_convex_space 𝕜 E _ _ _ t₁) (h₂ : @locally_convex_space 𝕜 E _ _ _ t₂)
  {t : topological_space F} [locally_convex_space 𝕜 F] {f : E →ₗ[𝕜] F}

lemma locally_convex_space_Inf :
  @locally_convex_space 𝕜 E _ _ _ (Inf ts) :=
begin
  letI : topological_space E := Inf ts,

  refine locally_convex_space.of_bases 𝕜 E _ _ (λ x, nhds_Inf ▸ _) _,
end

include h'

#check nhds_infi
#check has_basis_infi

lemma locally_convex_space_infi :
  @locally_convex_space 𝕜 E _ _ _ (⨅ i, ts' i) :=
begin
  letI : topological_space E := ⨅ i, ts' i,

  refine locally_convex_space.of_bases 𝕜 E
    (λ x, λ If : set ι × (ι → set E), ⋂ i ∈ If.1, If.2 i) _ _ _,
end

omit h'

include h₁ h₂

@[to_additive] lemma topological_group_inf :
  @topological_group G (t₁ ⊓ t₂) _ :=
by {rw inf_eq_infi, refine topological_group_infi (λ b, _), cases b; assumption}

omit h₁ h₂

@[to_additive] lemma topological_group_induced :
  @topological_group G (t.induced f) _ :=
{ continuous_inv :=
    begin
      letI : topological_space G := t.induced f,
      refine continuous_induced_rng _,
      simp_rw [function.comp, map_inv],
      exact continuous_inv.comp (continuous_induced_dom : continuous f)
    end,
  continuous_mul := @has_continuous_mul.continuous_mul G (t.induced f) _
    (@has_continuous_mul_induced G H _ _ t _ _ _ f) }

end lattice_ops

section tmp

variables {α : Type*}

open set

lemma has_basis_infi' {ι : Type*} {ι' : ι → Type*} {l : ι → filter α}
  {p : Π i, ι' i → Prop} {s : Π i, ι' i → set α} (hl : ∀ i, (l i).has_basis (p i) (s i)) :
  (⨅ i, l i).has_basis (λ If : (Σ (I : set ι), I.pi p), finite If.1)
    (λ If : (Σ (I : set ι), I.pi p), ⋂ i ∈ If.1, s i (If.2.1 i)) :=
⟨begin
  intro t,
  split,
  { simp only [mem_infi', (hl _).mem_iff],
    rintros ⟨I, hI, V, hV, -, hVt, -⟩,
    choose u hu using hV,
    refine ⟨⟨I, u⟩, ⟨hI, λ i _, (hu i).1⟩, _⟩,
    rw hVt,
    exact Inter_mono (λ i, Inter_mono $ λ hi, (hu i).2) },
  { rintros ⟨⟨I, f⟩, ⟨hI₁, hI₂⟩, hsub⟩,
    refine mem_of_superset _ hsub,
    exact (bInter_mem hI₁).mpr (λ i hi, mem_infi_of_mem i $ (hl i).mem_of_mem $ hI₂ _ hi) }
end⟩

end tmp
